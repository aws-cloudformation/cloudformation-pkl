/// AWS::Backup::LogicallyAirGappedBackupVault
///
/// Generated by rain build --pkl-class AWS::Backup::LogicallyAirGappedBackupVault
module aws.backup.logicallyairgappedbackupvault

import "../../cloudformation.pkl"

typealias LogicallyAirGappedBackupVaultBackupVaultNamePattern = String|Mapping


/// 
open class LogicallyAirGappedBackupVaultNotificationObjectType {
    BackupVaultEvents: Listing<String|Mapping>
    SNSTopicArn: String|Mapping
}

/// Resource Type definition for AWS::Backup::LogicallyAirGappedBackupVault
open class LogicallyAirGappedBackupVault extends cloudformation.Resource {

    Type = "AWS::Backup::LogicallyAirGappedBackupVault"


    /// 
    hidden AccessPolicy: (Dynamic)?

    /// 
    hidden BackupVaultName: LogicallyAirGappedBackupVaultBackupVaultNamePattern

    /// 
    hidden BackupVaultTags: (LogicallyAirGappedBackupVaultLogicallyAirGappedBackupVaultBackupVaultTags)?

    /// 
    hidden MaxRetentionDays: Int|Mapping

    /// 
    hidden MinRetentionDays: Int|Mapping

    /// 
    hidden Notifications: (LogicallyAirGappedBackupVaultNotificationObjectType)?

    /// 
    hidden VaultState: (String|Mapping)?

    /// 
    hidden VaultType: (String|Mapping)?

    Properties {
        ["AccessPolicy"] = if (AccessPolicy == null) null else AccessPolicy
        ["BackupVaultName"] = if (BackupVaultName == null) null else BackupVaultName
        ["BackupVaultTags"] = if (BackupVaultTags == null) null else BackupVaultTags
        ["MaxRetentionDays"] = if (MaxRetentionDays == null) null else MaxRetentionDays
        ["MinRetentionDays"] = if (MinRetentionDays == null) null else MinRetentionDays
        ["Notifications"] = if (Notifications == null) null else Notifications
        ["VaultState"] = if (VaultState == null) null else VaultState
        ["VaultType"] = if (VaultType == null) null else VaultType
    }

}


typealias LogicallyAirGappedBackupVaultLogicallyAirGappedBackupVaultBackupVaultTags = Mapping<String, Any>
