/// AWS::WAFv2::WebACL
///
/// Generated by rain build --pkl-class AWS::WAFv2::WebACL
module aws.wafv2.webacl

import "../../cloudformation.pkl"

/// Configures how to use the Account creation fraud prevention managed rule group in the web ACL
open class WebACLAWSManagedRulesACFPRuleSet {
    CreationPath: String|Mapping
    EnableRegexInPath: (Boolean|Mapping)?
    RegistrationPagePath: String|Mapping
    RequestInspection: WebACLRequestInspectionACFP
    ResponseInspection: (WebACLResponseInspection)?
}

/// Configures how to use the Account Takeover Prevention managed rule group in the web ACL
open class WebACLAWSManagedRulesATPRuleSet {
    EnableRegexInPath: (Boolean|Mapping)?
    LoginPath: String|Mapping
    RequestInspection: (WebACLRequestInspection)?
    ResponseInspection: (WebACLResponseInspection)?
}

typealias AWSManagedRulesBotControlRuleSetInspectionLevel = "COMMON"|"TARGETED"

/// Configures how to use the Bot Control managed rule group in the web ACL
open class WebACLAWSManagedRulesBotControlRuleSet {
    EnableMachineLearning: (Boolean|Mapping)?
    InspectionLevel: AWSManagedRulesBotControlRuleSetInspectionLevel|Mapping
}

typealias WebACLAddressField = WebACLFieldIdentifier


/// Allow traffic towards application.
open class WebACLAllowAction {
    CustomRequestHandling: (WebACLCustomRequestHandling)?
}

/// 
open class WebACLAndStatement {
    Statements: Listing<WebACLStatement>
}

/// AssociationConfig for body inspection
open class WebACLAssociationConfig {
    RequestBody: (WebACLRequestBody)?
}

/// Block traffic towards application.
open class WebACLBlockAction {
    CustomResponse: (WebACLCustomResponse)?
}

/// The body of a web request. This immediately follows the request headers.
open class WebACLBody {
    OversizeHandling: (WebACLOversizeHandling)?
}

typealias WebACLBodyParsingFallbackBehavior = String|Mapping


/// Byte Match statement.
open class WebACLByteMatchStatement {
    FieldToMatch: WebACLFieldToMatch
    PositionalConstraint: WebACLPositionalConstraint
    SearchString: (WebACLSearchString)?
    SearchStringBase64: (WebACLSearchStringBase64)?
    TextTransformations: Listing<WebACLTextTransformation>
}

/// Checks valid token exists with request.
open class WebACLCaptchaAction {
    CustomRequestHandling: (WebACLCustomRequestHandling)?
}

/// 
open class WebACLCaptchaConfig {
    ImmunityTimeProperty: (WebACLImmunityTimeProperty)?
}

/// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
open class WebACLChallengeAction {
    CustomRequestHandling: (WebACLCustomRequestHandling)?
}

/// 
open class WebACLChallengeConfig {
    ImmunityTimeProperty: (WebACLImmunityTimeProperty)?
}

/// The pattern to look for in the request cookies.
open class WebACLCookieMatchPattern {
    All: (Dynamic)?
    ExcludedCookies: (Listing<String|Mapping>)?
    IncludedCookies: (Listing<String|Mapping>)?
}

/// Includes cookies of a web request.
open class WebACLCookies {
    MatchPattern: WebACLCookieMatchPattern
    MatchScope: WebACLMapMatchScope
    OversizeHandling: WebACLOversizeHandling
}

/// Allow traffic towards application.
open class WebACLCountAction {
    CustomRequestHandling: (WebACLCustomRequestHandling)?
}

/// HTTP header.
open class WebACLCustomHTTPHeader {
    Name: WebACLCustomHTTPHeaderName
    Value: WebACLCustomHTTPHeaderValue
}

typealias WebACLCustomHTTPHeaderName = String|Mapping


typealias WebACLCustomHTTPHeaderValue = String|Mapping


/// Custom request handling.
open class WebACLCustomRequestHandling {
    InsertHeaders: Listing<WebACLCustomHTTPHeader>
}

/// Custom response.
open class WebACLCustomResponse {
    CustomResponseBodyKey: (String(matches(Regex(#"^[\w\-]+$"#)))|Mapping)?
    ResponseCode: WebACLResponseStatusCode
    ResponseHeaders: (Listing<WebACLCustomHTTPHeader>)?
}

typealias WebACLCustomResponseBodies = Mapping<String, Any>


/// Custom response body.
open class WebACLCustomResponseBody {
    Content: WebACLResponseContent
    ContentType: WebACLResponseContentType
}

/// Default Action WebACL will take against ingress traffic when there is no matching Rule.
open class WebACLDefaultAction {
    Allow: (WebACLAllowAction)?
    Block: (WebACLBlockAction)?
}

typealias WebACLEntityDescription = String|Mapping


typealias WebACLEntityId = String|Mapping


typealias WebACLEntityName = String|Mapping


typealias WebACLEvaluationWindowSec = Int|Mapping


/// Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
open class WebACLExcludedRule {
    Name: WebACLEntityName
}

typealias WebACLExcludedRules = Listing<(WebACLExcludedRule)?>


/// 
open class WebACLFieldIdentifier {
    Identifier: String(matches(Regex(#".*\S.*"#)))|Mapping
}

/// Field of the request to match.
open class WebACLFieldToMatch {
    AllQueryArguments: (Dynamic)?
    Body: (WebACLBody)?
    Cookies: (WebACLCookies)?
    Headers: (WebACLHeaders)?
    JA3Fingerprint: (WebACLJA3Fingerprint)?
    JsonBody: (WebACLJsonBody)?
    Method: (Dynamic)?
    QueryString: (Dynamic)?
    SingleHeader: (Dynamic)?
    SingleQueryArgument: (Dynamic)?
    UriPath: (Dynamic)?
}

typealias ForwardedIPConfigurationFallbackBehavior = "MATCH"|"NO_MATCH"

/// 
open class WebACLForwardedIPConfiguration {
    FallbackBehavior: ForwardedIPConfigurationFallbackBehavior|Mapping
    HeaderName: String(matches(Regex(#"^[a-zA-Z0-9-]+{1,255}$"#)))|Mapping
}

/// 
open class WebACLGeoMatchStatement {
    CountryCodes: (Listing<String|Mapping>)?
    ForwardedIPConfig: (WebACLForwardedIPConfiguration)?
}

/// The pattern to look for in the request headers.
open class WebACLHeaderMatchPattern {
    All: (Dynamic)?
    ExcludedHeaders: (Listing<String|Mapping>)?
    IncludedHeaders: (Listing<String|Mapping>)?
}

/// Includes headers of a web request.
open class WebACLHeaders {
    MatchPattern: WebACLHeaderMatchPattern
    MatchScope: WebACLMapMatchScope
    OversizeHandling: WebACLOversizeHandling
}

typealias IPSetForwardedIPConfigurationFallbackBehavior = "MATCH"|"NO_MATCH"

typealias IPSetForwardedIPConfigurationPosition = "FIRST"|"LAST"|"ANY"

/// 
open class WebACLIPSetForwardedIPConfiguration {
    FallbackBehavior: IPSetForwardedIPConfigurationFallbackBehavior|Mapping
    HeaderName: String(matches(Regex(#"^[a-zA-Z0-9-]+{1,255}$"#)))|Mapping
    Position: IPSetForwardedIPConfigurationPosition|Mapping
}

/// 
open class WebACLIPSetReferenceStatement {
    Arn: WebACLResourceArn
    IPSetForwardedIPConfig: (WebACLIPSetForwardedIPConfiguration)?
}

/// 
open class WebACLImmunityTimeProperty {
    ImmunityTime: Int|Mapping
}

typealias JA3FingerprintFallbackBehavior = "MATCH"|"NO_MATCH"

/// Includes the JA3 fingerprint of a web request.
open class WebACLJA3Fingerprint {
    FallbackBehavior: JA3FingerprintFallbackBehavior|Mapping
}

/// Inspect the request body as JSON. The request body immediately follows the request headers.
open class WebACLJsonBody {
    InvalidFallbackBehavior: (WebACLBodyParsingFallbackBehavior)?
    MatchPattern: WebACLJsonMatchPattern
    MatchScope: WebACLJsonMatchScope
    OversizeHandling: (WebACLOversizeHandling)?
}

/// The pattern to look for in the JSON body.
open class WebACLJsonMatchPattern {
    All: (Dynamic)?
    IncludedPaths: (Listing<WebACLJsonPointerPath>)?
}

typealias WebACLJsonMatchScope = String|Mapping


typealias WebACLJsonPointerPath = String|Mapping


/// 
open class WebACLLabel {
    Name: WebACLLabelName
}

typealias WebACLLabelMatchKey = String|Mapping


typealias WebACLLabelMatchScope = String|Mapping


/// 
open class WebACLLabelMatchStatement {
    Key: WebACLLabelMatchKey
    Scope: WebACLLabelMatchScope
}

typealias WebACLLabelName = String|Mapping


typealias ManagedRuleGroupConfigPayloadType = "JSON"|"FORM_ENCODED"

/// ManagedRuleGroupConfig.
open class WebACLManagedRuleGroupConfig {
    AWSManagedRulesACFPRuleSet: (WebACLAWSManagedRulesACFPRuleSet)?
    AWSManagedRulesATPRuleSet: (WebACLAWSManagedRulesATPRuleSet)?
    AWSManagedRulesBotControlRuleSet: (WebACLAWSManagedRulesBotControlRuleSet)?
    LoginPath: (String(matches(Regex(#".*\S.*"#)))|Mapping)?
    PasswordField: (WebACLFieldIdentifier)?
    PayloadType: (ManagedRuleGroupConfigPayloadType|Mapping)?
    UsernameField: (WebACLFieldIdentifier)?
}

/// 
open class WebACLManagedRuleGroupStatement {
    ExcludedRules: (Listing<WebACLExcludedRule>)?
    ManagedRuleGroupConfigs: (Listing<WebACLManagedRuleGroupConfig>)?
    Name: WebACLEntityName
    RuleActionOverrides: (Listing<WebACLRuleActionOverride>)?
    ScopeDownStatement: (WebACLStatement)?
    VendorName: String|Mapping
    Version: (String(matches(Regex(#"^[\w#:\.\-/]+$"#)))|Mapping)?
}

typealias WebACLMapMatchScope = String|Mapping


/// 
open class WebACLNotStatement {
    Statement: WebACLStatement
}

/// 
open class WebACLOrStatement {
    Statements: Listing<WebACLStatement>
}

/// Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
open class WebACLOverrideAction {
    Count: (Dynamic)?
    None: (Dynamic)?
}

typealias WebACLOversizeHandling = String|Mapping


typealias WebACLPhoneNumberField = WebACLFieldIdentifier


typealias WebACLPositionalConstraint = String|Mapping


typealias WebACLQueryString = Dynamic


typealias RateBasedStatementAggregateKeyType = "CONSTANT"|"IP"|"FORWARDED_IP"|"CUSTOM_KEYS"

/// 
open class WebACLRateBasedStatement {
    AggregateKeyType: RateBasedStatementAggregateKeyType|Mapping
    CustomKeys: (Listing<WebACLRateBasedStatementCustomKey>)?
    EvaluationWindowSec: (WebACLEvaluationWindowSec)?
    ForwardedIPConfig: (WebACLForwardedIPConfiguration)?
    Limit: WebACLRateLimit
    ScopeDownStatement: (WebACLStatement)?
}

/// Specifies a single custom aggregate key for a rate-base rule.
open class WebACLRateBasedStatementCustomKey {
    Cookie: (WebACLRateLimitCookie)?
    ForwardedIP: (WebACLRateLimitForwardedIP)?
    HTTPMethod: (WebACLRateLimitHTTPMethod)?
    Header: (WebACLRateLimitHeader)?
    IP: (WebACLRateLimitIP)?
    LabelNamespace: (WebACLRateLimitLabelNamespace)?
    QueryArgument: (WebACLRateLimitQueryArgument)?
    QueryString: (WebACLRateLimitQueryString)?
    UriPath: (WebACLRateLimitUriPath)?
}

typealias WebACLRateLimit = Int|Mapping


/// Specifies a cookie as an aggregate key for a rate-based rule.
open class WebACLRateLimitCookie {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<WebACLTextTransformation>
}

typealias WebACLRateLimitForwardedIP = Dynamic


typealias WebACLRateLimitHTTPMethod = Dynamic


/// Specifies a header as an aggregate key for a rate-based rule.
open class WebACLRateLimitHeader {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<WebACLTextTransformation>
}

typealias WebACLRateLimitIP = Dynamic


/// Specifies a label namespace to use as an aggregate key for a rate-based rule.
open class WebACLRateLimitLabelNamespace {
    Namespace: String(matches(Regex(#"^[0-9A-Za-z_:-]{1,1024}$"#)))|Mapping
}

/// Specifies a query argument in the request as an aggregate key for a rate-based rule.
open class WebACLRateLimitQueryArgument {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<WebACLTextTransformation>
}

/// Specifies the request's query string as an aggregate key for a rate-based rule.
open class WebACLRateLimitQueryString {
    TextTransformations: Listing<WebACLTextTransformation>
}

/// Specifies the request's URI Path as an aggregate key for a rate-based rule.
open class WebACLRateLimitUriPath {
    TextTransformations: Listing<WebACLTextTransformation>
}

/// 
open class WebACLRegexMatchStatement {
    FieldToMatch: WebACLFieldToMatch
    RegexString: String|Mapping
    TextTransformations: Listing<WebACLTextTransformation>
}

/// 
open class WebACLRegexPatternSetReferenceStatement {
    Arn: WebACLResourceArn
    FieldToMatch: WebACLFieldToMatch
    TextTransformations: Listing<WebACLTextTransformation>
}

typealias WebACLRequestBody = Mapping<String, Any>


/// Configures the inspection size in the request body.
open class WebACLRequestBodyAssociatedResourceTypeConfig {
    DefaultSizeInspectionLimit: WebACLSizeInspectionLimit
}

typealias RequestInspectionPayloadType = "JSON"|"FORM_ENCODED"

/// Configures the inspection of login requests
open class WebACLRequestInspection {
    PasswordField: WebACLFieldIdentifier
    PayloadType: RequestInspectionPayloadType|Mapping
    UsernameField: WebACLFieldIdentifier
}

typealias RequestInspectionACFPPayloadType = "JSON"|"FORM_ENCODED"

/// Configures the inspection of sign-up requests
open class WebACLRequestInspectionACFP {
    AddressFields: (Listing<WebACLAddressField>)?
    EmailField: (WebACLFieldIdentifier)?
    PasswordField: (WebACLFieldIdentifier)?
    PayloadType: RequestInspectionACFPPayloadType|Mapping
    PhoneNumberFields: (Listing<WebACLPhoneNumberField>)?
    UsernameField: (WebACLFieldIdentifier)?
}

typealias WebACLResourceArn = String|Mapping


typealias WebACLResponseContent = String|Mapping


typealias WebACLResponseContentType = String|Mapping


/// Configures the inspection of login responses
open class WebACLResponseInspection {
    BodyContains: (WebACLResponseInspectionBodyContains)?
    Header: (WebACLResponseInspectionHeader)?
    Json: (WebACLResponseInspectionJson)?
    StatusCode: (WebACLResponseInspectionStatusCode)?
}

/// Response body contents that indicate success or failure of a login request
open class WebACLResponseInspectionBodyContains {
    FailureStrings: Listing<String|Mapping>
    SuccessStrings: Listing<String|Mapping>
}

/// Response headers that indicate success or failure of a login request
open class WebACLResponseInspectionHeader {
    FailureValues: Listing<String|Mapping>
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    SuccessValues: Listing<String|Mapping>
}

/// Response JSON that indicate success or failure of a login request
open class WebACLResponseInspectionJson {
    FailureValues: Listing<String|Mapping>
    Identifier: String(matches(Regex(#".*\S.*"#)))|Mapping
    SuccessValues: Listing<String|Mapping>
}

/// Response status codes that indicate success or failure of a login request
open class WebACLResponseInspectionStatusCode {
    FailureCodes: Listing<Int|Mapping>
    SuccessCodes: Listing<Int|Mapping>
}

typealias WebACLResponseStatusCode = Int|Mapping


/// Rule of WebACL that contains condition and action.
open class WebACLRule {
    Action: (WebACLRuleAction)?
    CaptchaConfig: (WebACLCaptchaConfig)?
    ChallengeConfig: (WebACLChallengeConfig)?
    Name: WebACLEntityName
    OverrideAction: (WebACLOverrideAction)?
    Priority: WebACLRulePriority
    RuleLabels: (Listing<WebACLLabel>)?
    Statement: WebACLStatement
    VisibilityConfig: WebACLVisibilityConfig
}

/// Action taken when Rule matches its condition.
open class WebACLRuleAction {
    Allow: (WebACLAllowAction)?
    Block: (WebACLBlockAction)?
    Captcha: (WebACLCaptchaAction)?
    Challenge: (WebACLChallengeAction)?
    Count: (WebACLCountAction)?
}

/// Action override for rules in the rule group.
open class WebACLRuleActionOverride {
    ActionToUse: WebACLRuleAction
    Name: WebACLEntityName
}

/// 
open class WebACLRuleGroupReferenceStatement {
    Arn: WebACLResourceArn
    ExcludedRules: (Listing<WebACLExcludedRule>)?
    RuleActionOverrides: (Listing<WebACLRuleActionOverride>)?
}

typealias WebACLRulePriority = Int|Mapping


typealias WebACLRules = Listing<(WebACLRule)?>


typealias WebACLScope = String|Mapping


typealias WebACLSearchString = String|Mapping


typealias WebACLSearchStringBase64 = String|Mapping


typealias WebACLSensitivityLevel = String|Mapping


/// 
open class WebACLSingleHeader {
    Name: (String|Mapping)?
}

/// 
open class WebACLSingleQueryArgument {
    Name: (String|Mapping)?
}

typealias SizeConstraintStatementComparisonOperator = "EQ"|"NE"|"LE"|"LT"|"GE"|"GT"

/// Size Constraint statement.
open class WebACLSizeConstraintStatement {
    ComparisonOperator: SizeConstraintStatementComparisonOperator|Mapping
    FieldToMatch: WebACLFieldToMatch
    Size: Number|Mapping
    TextTransformations: Listing<WebACLTextTransformation>
}

typealias WebACLSizeInspectionLimit = String|Mapping


/// Sqli Match Statement.
open class WebACLSqliMatchStatement {
    FieldToMatch: WebACLFieldToMatch
    SensitivityLevel: (WebACLSensitivityLevel)?
    TextTransformations: Listing<WebACLTextTransformation>
}

/// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
open class WebACLStatement {
    AndStatement: (WebACLAndStatement)?
    ByteMatchStatement: (WebACLByteMatchStatement)?
    GeoMatchStatement: (WebACLGeoMatchStatement)?
    IPSetReferenceStatement: (WebACLIPSetReferenceStatement)?
    LabelMatchStatement: (WebACLLabelMatchStatement)?
    ManagedRuleGroupStatement: (WebACLManagedRuleGroupStatement)?
    NotStatement: (WebACLNotStatement)?
    OrStatement: (WebACLOrStatement)?
    RateBasedStatement: (WebACLRateBasedStatement)?
    RegexMatchStatement: (WebACLRegexMatchStatement)?
    RegexPatternSetReferenceStatement: (WebACLRegexPatternSetReferenceStatement)?
    RuleGroupReferenceStatement: (WebACLRuleGroupReferenceStatement)?
    SizeConstraintStatement: (WebACLSizeConstraintStatement)?
    SqliMatchStatement: (WebACLSqliMatchStatement)?
    XssMatchStatement: (WebACLXssMatchStatement)?
}

/// 
open class WebACLTag {
    Key: (String|Mapping)?
    Value: (String|Mapping)?
}

/// Text Transformation on the Search String before match.
open class WebACLTextTransformation {
    Priority: WebACLTextTransformationPriority
    Type: WebACLTextTransformationType
}

typealias WebACLTextTransformationPriority = Int|Mapping


typealias WebACLTextTransformationType = String|Mapping


typealias WebACLTokenDomains = Listing<(String(matches(Regex(#"^[\w\.\-/]+$"#)))|Mapping)?>


typealias WebACLUriPath = Dynamic


/// Visibility Metric of the WebACL.
open class WebACLVisibilityConfig {
    CloudWatchMetricsEnabled: Boolean|Mapping
    MetricName: String|Mapping
    SampledRequestsEnabled: Boolean|Mapping
}

/// Xss Match Statement.
open class WebACLXssMatchStatement {
    FieldToMatch: WebACLFieldToMatch
    TextTransformations: Listing<WebACLTextTransformation>
}

/// Contains the Rules that identify the requests that you want to allow, block, or count. In a WebACL, you also specify a default action (ALLOW or BLOCK), and the action for each Rule that you add to a WebACL, for example, block requests from specified IP addresses or block requests from specified referrers. You also associate the WebACL with a CloudFront distribution to identify the requests that you want AWS WAF to filter. If you add more than one Rule to a WebACL, a request needs to match only one of the specifications to be allowed, blocked, or counted.
open class WebACL extends cloudformation.Resource {

    Type = "AWS::WAFv2::WebACL"


    /// 
    hidden AssociationConfig: (WebACLAssociationConfig)?

    /// 
    hidden CaptchaConfig: (WebACLCaptchaConfig)?

    /// 
    hidden ChallengeConfig: (WebACLChallengeConfig)?

    /// 
    hidden CustomResponseBodies: (WebACLCustomResponseBodies)?

    /// 
    hidden DefaultAction: WebACLDefaultAction

    /// 
    hidden Description: (WebACLEntityDescription)?

    /// 
    hidden Name: (WebACLEntityName)?

    /// Collection of Rules.
    hidden Rules: (Listing<WebACLRule>)?

    /// 
    hidden Scope: WebACLScope

    /// 
    hidden Tags: (Listing<WebACLTag>)?

    /// 
    hidden TokenDomains: (WebACLTokenDomains)?

    /// 
    hidden VisibilityConfig: WebACLVisibilityConfig

    Properties {
        ["AssociationConfig"] = if (AssociationConfig == null) null else AssociationConfig
        ["CaptchaConfig"] = if (CaptchaConfig == null) null else CaptchaConfig
        ["ChallengeConfig"] = if (ChallengeConfig == null) null else ChallengeConfig
        ["CustomResponseBodies"] = if (CustomResponseBodies == null) null else CustomResponseBodies
        ["DefaultAction"] = if (DefaultAction == null) null else DefaultAction
        ["Description"] = if (Description == null) null else Description
        ["Name"] = if (Name == null) null else Name
        ["Rules"] = if (Rules == null) null else Rules
        ["Scope"] = if (Scope == null) null else Scope
        ["Tags"] = if (Tags == null) null else Tags
        ["TokenDomains"] = if (TokenDomains == null) null else TokenDomains
        ["VisibilityConfig"] = if (VisibilityConfig == null) null else VisibilityConfig
    }

}
