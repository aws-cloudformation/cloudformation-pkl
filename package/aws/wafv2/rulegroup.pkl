/// AWS::WAFv2::RuleGroup
///
/// Generated by rain build --pkl-class AWS::WAFv2::RuleGroup
module aws.wafv2.rulegroup

import "../../cloudformation.pkl"

/// Allow traffic towards application.
open class RuleGroupAllowAction {
    CustomRequestHandling: (RuleGroupCustomRequestHandling)?
}

/// 
open class RuleGroupAndStatement {
    Statements: Listing<RuleGroupStatement>
}

/// Block traffic towards application.
open class RuleGroupBlockAction {
    CustomResponse: (RuleGroupCustomResponse)?
}

/// The body of a web request. This immediately follows the request headers.
open class RuleGroupBody {
    OversizeHandling: (RuleGroupOversizeHandling)?
}

typealias RuleGroupBodyParsingFallbackBehavior = String|Mapping


/// Byte Match statement.
open class RuleGroupByteMatchStatement {
    FieldToMatch: RuleGroupFieldToMatch
    PositionalConstraint: RuleGroupPositionalConstraint
    SearchString: (RuleGroupSearchString)?
    SearchStringBase64: (RuleGroupSearchStringBase64)?
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// Checks valid token exists with request.
open class RuleGroupCaptchaAction {
    CustomRequestHandling: (RuleGroupCustomRequestHandling)?
}

/// 
open class RuleGroupCaptchaConfig {
    ImmunityTimeProperty: (RuleGroupImmunityTimeProperty)?
}

/// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
open class RuleGroupChallengeAction {
    CustomRequestHandling: (RuleGroupCustomRequestHandling)?
}

/// 
open class RuleGroupChallengeConfig {
    ImmunityTimeProperty: (RuleGroupImmunityTimeProperty)?
}

/// The pattern to look for in the request cookies.
open class RuleGroupCookieMatchPattern {
    All: (Dynamic)?
    ExcludedCookies: (Listing<String|Mapping>)?
    IncludedCookies: (Listing<String|Mapping>)?
}

/// Includes cookies of a web request.
open class RuleGroupCookies {
    MatchPattern: RuleGroupCookieMatchPattern
    MatchScope: RuleGroupMapMatchScope
    OversizeHandling: RuleGroupOversizeHandling
}

/// Count traffic towards application.
open class RuleGroupCountAction {
    CustomRequestHandling: (RuleGroupCustomRequestHandling)?
}

/// HTTP header.
open class RuleGroupCustomHTTPHeader {
    Name: RuleGroupCustomHTTPHeaderName
    Value: RuleGroupCustomHTTPHeaderValue
}

typealias RuleGroupCustomHTTPHeaderName = String|Mapping


typealias RuleGroupCustomHTTPHeaderValue = String|Mapping


/// Custom request handling.
open class RuleGroupCustomRequestHandling {
    InsertHeaders: Listing<RuleGroupCustomHTTPHeader>
}

/// Custom response.
open class RuleGroupCustomResponse {
    CustomResponseBodyKey: (String(matches(Regex(#"^[\w\-]+$"#)))|Mapping)?
    ResponseCode: RuleGroupResponseStatusCode
    ResponseHeaders: (Listing<RuleGroupCustomHTTPHeader>)?
}

typealias RuleGroupCustomResponseBodies = Mapping<String, Any>


/// Custom response body.
open class RuleGroupCustomResponseBody {
    Content: RuleGroupResponseContent
    ContentType: RuleGroupResponseContentType
}

typealias RuleGroupEntityDescription = String|Mapping


typealias RuleGroupEntityId = String|Mapping


typealias RuleGroupEntityName = String|Mapping


typealias RuleGroupEvaluationWindowSec = Int|Mapping


/// Field of the request to match.
open class RuleGroupFieldToMatch {
    AllQueryArguments: (Dynamic)?
    Body: (RuleGroupBody)?
    Cookies: (RuleGroupCookies)?
    Headers: (RuleGroupHeaders)?
    JA3Fingerprint: (RuleGroupJA3Fingerprint)?
    JsonBody: (RuleGroupJsonBody)?
    Method: (Dynamic)?
    QueryString: (Dynamic)?
    SingleHeader: (Dynamic)?
    SingleQueryArgument: (Dynamic)?
    UriPath: (Dynamic)?
}

typealias ForwardedIPConfigurationFallbackBehavior = "MATCH"|"NO_MATCH"

/// 
open class RuleGroupForwardedIPConfiguration {
    FallbackBehavior: ForwardedIPConfigurationFallbackBehavior|Mapping
    HeaderName: String(matches(Regex(#"^[a-zA-Z0-9-]+{1,255}$"#)))|Mapping
}

/// 
open class RuleGroupGeoMatchStatement {
    CountryCodes: (Listing<String|Mapping>)?
    ForwardedIPConfig: (RuleGroupForwardedIPConfiguration)?
}

/// The pattern to look for in the request headers.
open class RuleGroupHeaderMatchPattern {
    All: (Dynamic)?
    ExcludedHeaders: (Listing<String|Mapping>)?
    IncludedHeaders: (Listing<String|Mapping>)?
}

/// Includes headers of a web request.
open class RuleGroupHeaders {
    MatchPattern: RuleGroupHeaderMatchPattern
    MatchScope: RuleGroupMapMatchScope
    OversizeHandling: RuleGroupOversizeHandling
}

typealias IPSetForwardedIPConfigurationFallbackBehavior = "MATCH"|"NO_MATCH"

typealias IPSetForwardedIPConfigurationPosition = "FIRST"|"LAST"|"ANY"

/// 
open class RuleGroupIPSetForwardedIPConfiguration {
    FallbackBehavior: IPSetForwardedIPConfigurationFallbackBehavior|Mapping
    HeaderName: String(matches(Regex(#"^[a-zA-Z0-9-]+{1,255}$"#)))|Mapping
    Position: IPSetForwardedIPConfigurationPosition|Mapping
}

/// 
open class RuleGroupIPSetReferenceStatement {
    Arn: RuleGroupResourceArn
    IPSetForwardedIPConfig: (RuleGroupIPSetForwardedIPConfiguration)?
}

/// 
open class RuleGroupImmunityTimeProperty {
    ImmunityTime: Int|Mapping
}

typealias JA3FingerprintFallbackBehavior = "MATCH"|"NO_MATCH"

/// Includes the JA3 fingerprint of a web request.
open class RuleGroupJA3Fingerprint {
    FallbackBehavior: JA3FingerprintFallbackBehavior|Mapping
}

/// Inspect the request body as JSON. The request body immediately follows the request headers.
open class RuleGroupJsonBody {
    InvalidFallbackBehavior: (RuleGroupBodyParsingFallbackBehavior)?
    MatchPattern: RuleGroupJsonMatchPattern
    MatchScope: RuleGroupJsonMatchScope
    OversizeHandling: (RuleGroupOversizeHandling)?
}

/// The pattern to look for in the JSON body.
open class RuleGroupJsonMatchPattern {
    All: (Dynamic)?
    IncludedPaths: (Listing<RuleGroupJsonPointerPath>)?
}

typealias RuleGroupJsonMatchScope = String|Mapping


typealias RuleGroupJsonPointerPath = String|Mapping


/// 
open class RuleGroupLabel {
    Name: RuleGroupLabelName
}

typealias RuleGroupLabelMatchKey = String|Mapping


typealias RuleGroupLabelMatchScope = String|Mapping


/// 
open class RuleGroupLabelMatchStatement {
    Key: RuleGroupLabelMatchKey
    Scope: RuleGroupLabelMatchScope
}

typealias RuleGroupLabelName = String|Mapping


/// 
open class RuleGroupLabelSummary {
    Name: (RuleGroupLabelName)?
}

typealias RuleGroupMapMatchScope = String|Mapping


/// 
open class RuleGroupNotStatement {
    Statement: RuleGroupStatement
}

/// 
open class RuleGroupOrStatement {
    Statements: Listing<RuleGroupStatement>
}

typealias RuleGroupOversizeHandling = String|Mapping


typealias RuleGroupPositionalConstraint = String|Mapping


typealias RateBasedStatementAggregateKeyType = "IP"|"FORWARDED_IP"|"CONSTANT"|"CUSTOM_KEYS"

/// 
open class RuleGroupRateBasedStatement {
    AggregateKeyType: RateBasedStatementAggregateKeyType|Mapping
    CustomKeys: (Listing<RuleGroupRateBasedStatementCustomKey>)?
    EvaluationWindowSec: (RuleGroupEvaluationWindowSec)?
    ForwardedIPConfig: (RuleGroupForwardedIPConfiguration)?
    Limit: RuleGroupRateLimit
    ScopeDownStatement: (RuleGroupStatement)?
}

/// Specifies a single custom aggregate key for a rate-base rule.
open class RuleGroupRateBasedStatementCustomKey {
    Cookie: (RuleGroupRateLimitCookie)?
    ForwardedIP: (RuleGroupRateLimitForwardedIP)?
    HTTPMethod: (RuleGroupRateLimitHTTPMethod)?
    Header: (RuleGroupRateLimitHeader)?
    IP: (RuleGroupRateLimitIP)?
    LabelNamespace: (RuleGroupRateLimitLabelNamespace)?
    QueryArgument: (RuleGroupRateLimitQueryArgument)?
    QueryString: (RuleGroupRateLimitQueryString)?
    UriPath: (RuleGroupRateLimitUriPath)?
}

typealias RuleGroupRateLimit = Int|Mapping


/// Specifies a cookie as an aggregate key for a rate-based rule.
open class RuleGroupRateLimitCookie {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<RuleGroupTextTransformation>
}

typealias RuleGroupRateLimitForwardedIP = Dynamic


typealias RuleGroupRateLimitHTTPMethod = Dynamic


/// Specifies a header as an aggregate key for a rate-based rule.
open class RuleGroupRateLimitHeader {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<RuleGroupTextTransformation>
}

typealias RuleGroupRateLimitIP = Dynamic


/// Specifies a label namespace to use as an aggregate key for a rate-based rule.
open class RuleGroupRateLimitLabelNamespace {
    Namespace: String(matches(Regex(#"^[0-9A-Za-z_:-]{1,1024}$"#)))|Mapping
}

/// Specifies a query argument in the request as an aggregate key for a rate-based rule.
open class RuleGroupRateLimitQueryArgument {
    Name: String(matches(Regex(#".*\S.*"#)))|Mapping
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// Specifies the request's query string as an aggregate key for a rate-based rule.
open class RuleGroupRateLimitQueryString {
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// Specifies the request's URI Path as an aggregate key for a rate-based rule.
open class RuleGroupRateLimitUriPath {
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// 
open class RuleGroupRegexMatchStatement {
    FieldToMatch: RuleGroupFieldToMatch
    RegexString: String|Mapping
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// 
open class RuleGroupRegexPatternSetReferenceStatement {
    Arn: RuleGroupResourceArn
    FieldToMatch: RuleGroupFieldToMatch
    TextTransformations: Listing<RuleGroupTextTransformation>
}

typealias RuleGroupResourceArn = String|Mapping


typealias RuleGroupResponseContent = String|Mapping


typealias RuleGroupResponseContentType = String|Mapping


typealias RuleGroupResponseStatusCode = Int|Mapping


/// Rule of RuleGroup that contains condition and action.
open class RuleGroupRule {
    Action: (RuleGroupRuleAction)?
    CaptchaConfig: (RuleGroupCaptchaConfig)?
    ChallengeConfig: (RuleGroupChallengeConfig)?
    Name: RuleGroupEntityName
    Priority: RuleGroupRulePriority
    RuleLabels: (Listing<RuleGroupLabel>)?
    Statement: RuleGroupStatement
    VisibilityConfig: RuleGroupVisibilityConfig
}

/// Action taken when Rule matches its condition.
open class RuleGroupRuleAction {
    Allow: (RuleGroupAllowAction)?
    Block: (RuleGroupBlockAction)?
    Captcha: (RuleGroupCaptchaAction)?
    Challenge: (RuleGroupChallengeAction)?
    Count: (RuleGroupCountAction)?
}

/// 
open class RuleGroupRuleGroup {
    Arn: (RuleGroupResourceArn)?
    Capacity: (Int|Mapping)?
    Description: (RuleGroupEntityDescription)?
    Id: (RuleGroupEntityId)?
    Name: (RuleGroupEntityName)?
    Rules: (Listing<RuleGroupRule>)?
    VisibilityConfig: (RuleGroupVisibilityConfig)?
}

typealias RuleGroupRulePriority = Int|Mapping


typealias RuleGroupScope = String|Mapping


typealias RuleGroupSearchString = String|Mapping


typealias RuleGroupSearchStringBase64 = String|Mapping


typealias RuleGroupSensitivityLevel = String|Mapping


typealias SizeConstraintStatementComparisonOperator = "EQ"|"NE"|"LE"|"LT"|"GE"|"GT"

/// Size Constraint statement.
open class RuleGroupSizeConstraintStatement {
    ComparisonOperator: SizeConstraintStatementComparisonOperator|Mapping
    FieldToMatch: RuleGroupFieldToMatch
    Size: Number|Mapping
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// Sqli Match Statement.
open class RuleGroupSqliMatchStatement {
    FieldToMatch: RuleGroupFieldToMatch
    SensitivityLevel: (RuleGroupSensitivityLevel)?
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
open class RuleGroupStatement {
    AndStatement: (RuleGroupAndStatement)?
    ByteMatchStatement: (RuleGroupByteMatchStatement)?
    GeoMatchStatement: (RuleGroupGeoMatchStatement)?
    IPSetReferenceStatement: (RuleGroupIPSetReferenceStatement)?
    LabelMatchStatement: (RuleGroupLabelMatchStatement)?
    NotStatement: (RuleGroupNotStatement)?
    OrStatement: (RuleGroupOrStatement)?
    RateBasedStatement: (RuleGroupRateBasedStatement)?
    RegexMatchStatement: (RuleGroupRegexMatchStatement)?
    RegexPatternSetReferenceStatement: (RuleGroupRegexPatternSetReferenceStatement)?
    SizeConstraintStatement: (RuleGroupSizeConstraintStatement)?
    SqliMatchStatement: (RuleGroupSqliMatchStatement)?
    XssMatchStatement: (RuleGroupXssMatchStatement)?
}

/// 
open class RuleGroupTag {
    Key: (String|Mapping)?
    Value: (String|Mapping)?
}

/// Text Transformation on the Search String before match.
open class RuleGroupTextTransformation {
    Priority: RuleGroupTextTransformationPriority
    Type: RuleGroupTextTransformationType
}

typealias RuleGroupTextTransformationPriority = Int|Mapping


typealias RuleGroupTextTransformationType = String|Mapping


/// Visibility Metric of the RuleGroup.
open class RuleGroupVisibilityConfig {
    CloudWatchMetricsEnabled: Boolean|Mapping
    MetricName: String|Mapping
    SampledRequestsEnabled: Boolean|Mapping
}

/// Xss Match Statement.
open class RuleGroupXssMatchStatement {
    FieldToMatch: RuleGroupFieldToMatch
    TextTransformations: Listing<RuleGroupTextTransformation>
}

/// Contains the Rules that identify the requests that you want to allow, block, or count. In a RuleGroup, you also specify a default action (ALLOW or BLOCK), and the action for each Rule that you add to a RuleGroup, for example, block requests from specified IP addresses or block requests from specified referrers. You also associate the RuleGroup with a CloudFront distribution to identify the requests that you want AWS WAF to filter. If you add more than one Rule to a RuleGroup, a request needs to match only one of the specifications to be allowed, blocked, or counted.
open class RuleGroup extends cloudformation.Resource {

    Type = "AWS::WAFv2::RuleGroup"


    /// Collection of Available Labels.
    hidden AvailableLabels: (Listing<RuleGroupLabelSummary>)?

    /// 
    hidden Capacity: Int|Mapping

    /// Collection of Consumed Labels.
    hidden ConsumedLabels: (Listing<RuleGroupLabelSummary>)?

    /// 
    hidden CustomResponseBodies: (RuleGroupCustomResponseBodies)?

    /// 
    hidden Description: (RuleGroupEntityDescription)?

    /// 
    hidden Name: (RuleGroupEntityName)?

    /// Collection of Rules.
    hidden Rules: (Listing<RuleGroupRule>)?

    /// 
    hidden Scope: RuleGroupScope

    /// 
    hidden Tags: (Listing<RuleGroupTag>)?

    /// 
    hidden VisibilityConfig: RuleGroupVisibilityConfig

    Properties {
        ["AvailableLabels"] = if (AvailableLabels == null) null else AvailableLabels
        ["Capacity"] = if (Capacity == null) null else Capacity
        ["ConsumedLabels"] = if (ConsumedLabels == null) null else ConsumedLabels
        ["CustomResponseBodies"] = if (CustomResponseBodies == null) null else CustomResponseBodies
        ["Description"] = if (Description == null) null else Description
        ["Name"] = if (Name == null) null else Name
        ["Rules"] = if (Rules == null) null else Rules
        ["Scope"] = if (Scope == null) null else Scope
        ["Tags"] = if (Tags == null) null else Tags
        ["VisibilityConfig"] = if (VisibilityConfig == null) null else VisibilityConfig
    }

}
