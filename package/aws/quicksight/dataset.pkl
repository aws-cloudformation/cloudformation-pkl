/// AWS::QuickSight::DataSet
///
/// Generated by rain build --pkl-class AWS::QuickSight::DataSet
module aws.quicksight.dataset

import "../../cloudformation.pkl"

/// <p>A calculated column for a dataset.</p>
open class DataSetCalculatedColumn {
    ColumnId: String|Mapping
    ColumnName: String|Mapping
    Expression: String|Mapping
}

/// <p>A transform operation that casts a column to a different type.</p>
open class DataSetCastColumnTypeOperation {
    ColumnName: String|Mapping
    Format: (String|Mapping)?
    NewColumnType: DataSetColumnDataType
    SubType: (DataSetColumnDataSubType)?
}

typealias DataSetColumnDataSubType = String|Mapping


typealias DataSetColumnDataType = String|Mapping


/// <p>Metadata that contains a description for a column.</p>
open class DataSetColumnDescription {
    Text: (String|Mapping)?
}

/// <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
///
///             a variant type structure. For this structure to be valid, only one of the attributes can
///             be non-null.</p>
open class DataSetColumnGroup {
    GeoSpatialColumnGroup: (DataSetGeoSpatialColumnGroup)?
}

/// <p>A rule defined to grant access on one or more restricted columns.
///
///             Each dataset can have multiple rules.
///             To create a restricted column, you add it to one or more rules.
///             Each rule must contain at least one column and at least one user or group.
///             To be able to see a restricted column, a user or group needs to be added
///             to a rule for that column.</p>
open class DataSetColumnLevelPermissionRule {
    ColumnNames: (Listing<String|Mapping>)?
    Principals: (Listing<String|Mapping>)?
}

/// <p>A tag for a column in a
///
///             <code>
///                <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_TagColumnOperation.html">TagColumnOperation</a>
///             </code>
///             structure. This is a
///             variant type structure. For this structure to be valid, only one of the attributes can
///             be non-null.</p>
open class DataSetColumnTag {
    ColumnDescription: (DataSetColumnDescription)?
    ColumnGeographicRole: (DataSetGeoSpatialDataRole)?
}

typealias DataSetColumnTagName = String|Mapping


/// <p>A transform operation that creates calculated columns. Columns created in one such
///
///             operation form a lexical closure.</p>
open class DataSetCreateColumnsOperation {
    Columns: Listing<DataSetCalculatedColumn>
}

/// <p>A physical table type built from the results of the custom SQL query.</p>
open class DataSetCustomSql {
    Columns: Listing<DataSetInputColumn>
    DataSourceArn: String|Mapping
    Name: String|Mapping
    SqlQuery: String|Mapping
}

typealias DataSetDataSetImportMode = String|Mapping


/// <p>The refresh properties of a dataset.</p>
open class DataSetDataSetRefreshProperties {
    RefreshConfiguration: (DataSetRefreshConfiguration)?
}

/// <p>The usage configuration to apply to child datasets that reference this dataset as a source.</p>
open class DataSetDataSetUsageConfiguration {
    DisableUseAsDirectQuerySource: (Boolean|Mapping)?
    DisableUseAsImportedSource: (Boolean|Mapping)?
}

/// <p>A dataset parameter.</p>
open class DataSetDatasetParameter {
    DateTimeDatasetParameter: (DataSetDateTimeDatasetParameter)?
    DecimalDatasetParameter: (DataSetDecimalDatasetParameter)?
    IntegerDatasetParameter: (DataSetIntegerDatasetParameter)?
    StringDatasetParameter: (DataSetStringDatasetParameter)?
}

typealias DataSetDatasetParameterValueType = String|Mapping


/// <p>A date time parameter for a dataset.</p>
open class DataSetDateTimeDatasetParameter {
    DefaultValues: (DataSetDateTimeDatasetParameterDefaultValues)?
    Id: String(matches(Regex(#"^[a-zA-Z0-9-]+$"#)))|Mapping
    Name: String(matches(Regex(#"^[a-zA-Z0-9]+$"#)))|Mapping
    TimeGranularity: (DataSetTimeGranularity)?
    ValueType: DataSetDatasetParameterValueType
}

/// <p>The default values of a date time parameter.</p>
open class DataSetDateTimeDatasetParameterDefaultValues {
    StaticValues: (Listing<String|Mapping>)?
}

/// <p>A decimal parameter for a dataset.</p>
open class DataSetDecimalDatasetParameter {
    DefaultValues: (DataSetDecimalDatasetParameterDefaultValues)?
    Id: String(matches(Regex(#"^[a-zA-Z0-9-]+$"#)))|Mapping
    Name: String(matches(Regex(#"^[a-zA-Z0-9]+$"#)))|Mapping
    ValueType: DataSetDatasetParameterValueType
}

/// <p>The default values of a decimal parameter.</p>
open class DataSetDecimalDatasetParameterDefaultValues {
    StaticValues: (Listing<Number|Mapping>)?
}

/// <p>A FieldFolder element is a folder that contains fields and nested subfolders.</p>
open class DataSetFieldFolder {
    Columns: (Listing<String|Mapping>)?
    Description: (String|Mapping)?
}

typealias DataSetFieldFolderMap = Mapping<String, Any>


typealias DataSetFileFormat = String|Mapping


/// <p>A transform operation that filters rows based on a condition.</p>
open class DataSetFilterOperation {
    ConditionExpression: String|Mapping
}

/// <p>Geospatial column group that denotes a hierarchy.</p>
open class DataSetGeoSpatialColumnGroup {
    Columns: Listing<String|Mapping>
    CountryCode: (DataSetGeoSpatialCountryCode)?
    Name: String|Mapping
}

typealias DataSetGeoSpatialCountryCode = String|Mapping


typealias DataSetGeoSpatialDataRole = String|Mapping


/// <p>The incremental refresh configuration for a dataset.</p>
open class DataSetIncrementalRefresh {
    LookbackWindow: DataSetLookbackWindow
}

/// <p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>
open class DataSetIngestionWaitPolicy {
    IngestionWaitTimeInHours: (Number|Mapping)?
    WaitForSpiceIngestion: (Boolean|Mapping)?
}

/// <p>Metadata for a column that is used as the input of a transform operation.</p>
open class DataSetInputColumn {
    Name: String|Mapping
    SubType: (DataSetColumnDataSubType)?
    Type: DataSetInputColumnDataType
}

typealias DataSetInputColumnDataType = String|Mapping


/// <p>An integer parameter for a dataset.</p>
open class DataSetIntegerDatasetParameter {
    DefaultValues: (DataSetIntegerDatasetParameterDefaultValues)?
    Id: String(matches(Regex(#"^[a-zA-Z0-9-]+$"#)))|Mapping
    Name: String(matches(Regex(#"^[a-zA-Z0-9]+$"#)))|Mapping
    ValueType: DataSetDatasetParameterValueType
}

/// <p>The default values of an integer parameter.</p>
open class DataSetIntegerDatasetParameterDefaultValues {
    StaticValues: (Listing<Number|Mapping>)?
}

/// <p>The instructions associated with a join. </p>
open class DataSetJoinInstruction {
    LeftJoinKeyProperties: (DataSetJoinKeyProperties)?
    LeftOperand: String(matches(Regex(#"^[0-9a-zA-Z-]*$"#)))|Mapping
    OnClause: String|Mapping
    RightJoinKeyProperties: (DataSetJoinKeyProperties)?
    RightOperand: String(matches(Regex(#"^[0-9a-zA-Z-]*$"#)))|Mapping
    Type: DataSetJoinType
}

/// <p>Properties associated with the columns participating in a join.</p>
open class DataSetJoinKeyProperties {
    UniqueKey: (Boolean|Mapping)?
}

typealias DataSetJoinType = String|Mapping


/// <p>A <i>logical table</i> is a unit that joins and that data
///
///             transformations operate on. A logical table has a source, which can be either a physical
///             table or result of a join. When a logical table points to a physical table, the logical
///             table acts as a mutable copy of that physical table through transform operations.</p>
open class DataSetLogicalTable {
    Alias: String|Mapping
    DataTransforms: (Listing<DataSetTransformOperation>)?
    Source: (DataSetLogicalTableSource)?
}

typealias DataSetLogicalTableMap = Mapping<String, Any>


/// <p>Information about the source of a logical table. This is a variant type structure. For
///
///             this structure to be valid, only one of the attributes can be non-null.</p>
open class DataSetLogicalTableSource {
    DataSetArn: (String|Mapping)?
    JoinInstruction: (DataSetJoinInstruction)?
    PhysicalTableId: (String(matches(Regex(#"^[0-9a-zA-Z-]*$"#)))|Mapping)?
}

/// <p>The lookback window setup of an incremental refresh configuration.</p>
open class DataSetLookbackWindow {
    ColumnName: String|Mapping
    Size: Number|Mapping
    SizeUnit: DataSetLookbackWindowSizeUnit
}

typealias DataSetLookbackWindowSizeUnit = String|Mapping


/// <p>The configuration that overrides the existing default values for a dataset parameter that is inherited from another dataset.</p>
open class DataSetNewDefaultValues {
    DateTimeStaticValues: (Listing<String|Mapping>)?
    DecimalStaticValues: (Listing<Number|Mapping>)?
    IntegerStaticValues: (Listing<Number|Mapping>)?
    StringStaticValues: (Listing<String|Mapping>)?
}

/// <p>Output column.</p>
open class DataSetOutputColumn {
    Description: (String|Mapping)?
    Name: (String|Mapping)?
    SubType: (DataSetColumnDataSubType)?
    Type: (DataSetColumnDataType)?
}

/// <p>A transform operation that overrides the dataset parameter values that are defined in another dataset.</p>
open class DataSetOverrideDatasetParameterOperation {
    NewDefaultValues: (DataSetNewDefaultValues)?
    NewParameterName: (String(matches(Regex(#"^[a-zA-Z0-9]+$"#)))|Mapping)?
    ParameterName: String(matches(Regex(#"^[a-zA-Z0-9]+$"#)))|Mapping
}

/// <p>A view of a data source that contains information about the shape of the data in the
///
///             underlying source. This is a variant type structure. For this structure to be valid,
///             only one of the attributes can be non-null.</p>
open class DataSetPhysicalTable {
    CustomSql: (DataSetCustomSql)?
    RelationalTable: (DataSetRelationalTable)?
    S3Source: (DataSetS3Source)?
}

typealias DataSetPhysicalTableMap = Mapping<String, Any>


/// <p>A transform operation that projects columns. Operations that come after a projection
///
///             can only refer to projected columns.</p>
open class DataSetProjectOperation {
    ProjectedColumns: Listing<String|Mapping>
}

/// <p>The refresh configuration of a dataset.</p>
open class DataSetRefreshConfiguration {
    IncrementalRefresh: DataSetIncrementalRefresh
}

/// <p>A physical table type for relational data sources.</p>
open class DataSetRelationalTable {
    Catalog: (String|Mapping)?
    DataSourceArn: String|Mapping
    InputColumns: Listing<DataSetInputColumn>
    Name: String|Mapping
    Schema: (String|Mapping)?
}

/// <p>A transform operation that renames a column.</p>
open class DataSetRenameColumnOperation {
    ColumnName: String|Mapping
    NewColumnName: String|Mapping
}

/// <p>Permission for the resource.</p>
open class DataSetResourcePermission {
    Actions: Listing<String|Mapping>
    Principal: String|Mapping
}

/// <p>Information about a dataset that contains permissions for row-level security (RLS).
///
///             The permissions dataset maps fields to users or groups. For more information, see
///             <a href="https://docs.aws.amazon.com/quicksight/latest/user/restrict-access-to-a-data-set-using-row-level-security.html">Using Row-Level Security (RLS) to Restrict Access to a Dataset</a> in the <i>Amazon QuickSight User
///                 Guide</i>.</p>
///          <p>The option to deny permissions by setting <code>PermissionPolicy</code> to <code>DENY_ACCESS</code> is
///             not supported for new RLS datasets.</p>
open class DataSetRowLevelPermissionDataSet {
    Arn: String|Mapping
    FormatVersion: (DataSetRowLevelPermissionFormatVersion)?
    Namespace: (String(matches(Regex(#"^[a-zA-Z0-9._-]*$"#)))|Mapping)?
    PermissionPolicy: DataSetRowLevelPermissionPolicy
    Status: (DataSetStatus)?
}

typealias DataSetRowLevelPermissionFormatVersion = String|Mapping


typealias DataSetRowLevelPermissionPolicy = String|Mapping


/// <p>The configuration of tags on a dataset to set row-level security. </p>
open class DataSetRowLevelPermissionTagConfiguration {
    Status: (DataSetStatus)?
    TagRuleConfigurations: (Listing<Dynamic>)?
    TagRules: Listing<DataSetRowLevelPermissionTagRule>
}

/// <p>A set of rules associated with a tag.</p>
open class DataSetRowLevelPermissionTagRule {
    ColumnName: String|Mapping
    MatchAllValue: (String|Mapping)?
    TagKey: String|Mapping
    TagMultiValueDelimiter: (String|Mapping)?
}

/// <p>A physical table type for an S3 data source.</p>
open class DataSetS3Source {
    DataSourceArn: String|Mapping
    InputColumns: Listing<DataSetInputColumn>
    UploadSettings: (DataSetUploadSettings)?
}

typealias DataSetStatus = String|Mapping


/// <p>A string parameter for a dataset.</p>
open class DataSetStringDatasetParameter {
    DefaultValues: (DataSetStringDatasetParameterDefaultValues)?
    Id: String(matches(Regex(#"^[a-zA-Z0-9-]+$"#)))|Mapping
    Name: String(matches(Regex(#"^[a-zA-Z0-9]+$"#)))|Mapping
    ValueType: DataSetDatasetParameterValueType
}

/// <p>The default values of a string parameter.</p>
open class DataSetStringDatasetParameterDefaultValues {
    StaticValues: (Listing<String|Mapping>)?
}

/// <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
///
///             resource.</p>
open class DataSetTag {
    Key: String|Mapping
    Value: String|Mapping
}

/// <p>A transform operation that tags a column with additional information.</p>
open class DataSetTagColumnOperation {
    ColumnName: String|Mapping
    Tags: Listing<DataSetColumnTag>
}

typealias DataSetTextQualifier = String|Mapping


typealias DataSetTimeGranularity = String|Mapping


/// <p>A data transformation on a logical table. This is a variant type structure. For this
///
///             structure to be valid, only one of the attributes can be non-null.</p>
open class DataSetTransformOperation {
    CastColumnTypeOperation: (DataSetCastColumnTypeOperation)?
    CreateColumnsOperation: (DataSetCreateColumnsOperation)?
    FilterOperation: (DataSetFilterOperation)?
    OverrideDatasetParameterOperation: (DataSetOverrideDatasetParameterOperation)?
    ProjectOperation: (DataSetProjectOperation)?
    RenameColumnOperation: (DataSetRenameColumnOperation)?
    TagColumnOperation: (DataSetTagColumnOperation)?
    UntagColumnOperation: (DataSetUntagColumnOperation)?
}

/// <p>A transform operation that removes tags associated with a column.</p>
open class DataSetUntagColumnOperation {
    ColumnName: String|Mapping
    TagNames: Listing<DataSetColumnTagName>
}

/// <p>Information about the format for a source file or files.</p>
open class DataSetUploadSettings {
    ContainsHeader: (Boolean|Mapping)?
    Delimiter: (String|Mapping)?
    Format: (DataSetFileFormat)?
    StartFromRow: (Number|Mapping)?
    TextQualifier: (DataSetTextQualifier)?
}

/// Definition of the AWS::QuickSight::DataSet Resource Type.
open class DataSet extends cloudformation.Resource {

    Type = "AWS::QuickSight::DataSet"


    /// 
    hidden AwsAccountId: (String(matches(Regex(#"^[0-9]{12}$"#)))|Mapping)?

    /// <p>Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.</p>
    hidden ColumnGroups: (Listing<DataSetColumnGroup>)?

    /// <p>A set of one or more definitions of a <code>
    ///
    ///                <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a>
    ///             </code>.</p>
    hidden ColumnLevelPermissionRules: (Listing<DataSetColumnLevelPermissionRule>)?

    /// 
    hidden DataSetId: (String|Mapping)?

    /// 
    hidden DataSetRefreshProperties: (DataSetDataSetRefreshProperties)?

    /// 
    hidden DataSetUsageConfiguration: (DataSetDataSetUsageConfiguration)?

    /// <p>The parameter declarations of the dataset.</p>
    hidden DatasetParameters: (Listing<DataSetDatasetParameter>)?

    /// 
    hidden FieldFolders: (DataSetFieldFolderMap)?

    /// <p>When you create the dataset, Amazon QuickSight adds the dataset to these folders.</p>
    hidden FolderArns: (Listing<String|Mapping>)?

    /// 
    hidden ImportMode: (DataSetDataSetImportMode)?

    /// 
    hidden IngestionWaitPolicy: (DataSetIngestionWaitPolicy)?

    /// 
    hidden LogicalTableMap: (DataSetLogicalTableMap)?

    /// <p>The display name for the dataset.</p>
    hidden Name: (String|Mapping)?

    /// <p>A list of resource permissions on the dataset.</p>
    hidden Permissions: (Listing<DataSetResourcePermission>)?

    /// 
    hidden PhysicalTableMap: (DataSetPhysicalTableMap)?

    /// 
    hidden RowLevelPermissionDataSet: (DataSetRowLevelPermissionDataSet)?

    /// 
    hidden RowLevelPermissionTagConfiguration: (DataSetRowLevelPermissionTagConfiguration)?

    /// <p>Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.</p>
    hidden Tags: (Listing<DataSetTag>)?

    Properties {
        ["AwsAccountId"] = if (AwsAccountId == null) null else AwsAccountId
        ["ColumnGroups"] = if (ColumnGroups == null) null else ColumnGroups
        ["ColumnLevelPermissionRules"] = if (ColumnLevelPermissionRules == null) null else ColumnLevelPermissionRules
        ["DataSetId"] = if (DataSetId == null) null else DataSetId
        ["DataSetRefreshProperties"] = if (DataSetRefreshProperties == null) null else DataSetRefreshProperties
        ["DataSetUsageConfiguration"] = if (DataSetUsageConfiguration == null) null else DataSetUsageConfiguration
        ["DatasetParameters"] = if (DatasetParameters == null) null else DatasetParameters
        ["FieldFolders"] = if (FieldFolders == null) null else FieldFolders
        ["FolderArns"] = if (FolderArns == null) null else FolderArns
        ["ImportMode"] = if (ImportMode == null) null else ImportMode
        ["IngestionWaitPolicy"] = if (IngestionWaitPolicy == null) null else IngestionWaitPolicy
        ["LogicalTableMap"] = if (LogicalTableMap == null) null else LogicalTableMap
        ["Name"] = if (Name == null) null else Name
        ["Permissions"] = if (Permissions == null) null else Permissions
        ["PhysicalTableMap"] = if (PhysicalTableMap == null) null else PhysicalTableMap
        ["RowLevelPermissionDataSet"] = if (RowLevelPermissionDataSet == null) null else RowLevelPermissionDataSet
        ["RowLevelPermissionTagConfiguration"] = if (RowLevelPermissionTagConfiguration == null) null else RowLevelPermissionTagConfiguration
        ["Tags"] = if (Tags == null) null else Tags
    }

}
